package code;

/**
 * @author 刘佳俊
 *
 * 不用加减乘除做加法:
 *                  写一个函数，求两个整数之和，要求在函数体内不得使用 “+”、“-”、“*”、“/” 四则运算符号。
 *
 *  思路:
 *      1. 位运算  异或运算 ->  无进位相加    与运算之后左移一位  ->  相加之后的进位
 *
 *      2. 两数相加 不用 四则运算符  我们可以将 加法拆解  两数相加之后  (=========我们这里讨论的进位与无进位 都是 二进制 ==============  )
 *              一部分是加法之后产生的 进位值  (a & b)<<1   与运算之后左移一位
 *              一部分是无进位的加法得到的值   ( a ^ b)
 *
 *              两个数相加 = 无进位 + 进位值
 *              直到 进位值 0 直接返回 这个数
 *
 *              eg:
 *                  5 + 8  ->  0101 + 1000
 *
 *                  无进位 1101
 *                  进位值 0000
 *
 *                  进位值为0 直接返回 1101 即 13
 *
 *               ============================
 *                  3 + 5  ->   0011 + 0101
 *
 *                  无进位  0110
 *                  进位值  0010
 *
 *                  进位置不为0 无进位 加上 进位值
 *
 *                  0110 + 0010
 *
 *                  无进位 0100
 *                  进位值 0100
 *
 *                  进位不为0 无进位 加上 进位值
 *
 *                  0100 + 0100
 *
 *                  无进位 0000
 *                  进位值 1000
 *
 *                  进位不为0 无进位 加上 进位值
 *
 *                  0000 + 1000
 *
 *                  无进位 1000
 *                  进位值 0000
 *
 *                  进位值为0 直接返回 1000 即 8
 *
 *
 *
 *
 *
 *
 *
 *
 *
 */
public class _offer65_Add {

    public static int add(int a, int b) {

        // 无进位
        int noCarry;
        // 进位
        int carry;
        // 当一个 二进制位的加法 没有 进位 就表示 是一个数加上一个 0 所以可以直接返回那个0之外的数
        while (b != 0) {

            // 无进位相加
            noCarry = a ^ b;

            // 相加之后 产生的进位 的值
            carry = (a & b) << 1;


            a = noCarry;
            b = carry;
        }

        return a;
    }
}
