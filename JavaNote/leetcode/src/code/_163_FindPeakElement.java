package code;

/**
 * @author 刘佳俊
 *
 * 寻找峰值:
 *          峰值元素是指其值严格大于左右相邻值的元素。
 *          给你一个整数数组 nums，找到峰值元素并返回其索引。数组可能包含多个峰值，在这种情况下，返回 任何一个峰值 所在位置即可。
 *          对于所有有效的 i 都有 nums[i] != nums[i + 1]
 *
 * 思路:
 *      1. 局部最大值最小值问题,使用二分法 和 分情况讨论
 *
 *      2. 分情况讨论, 共有三种情况,这里寻找的是峰值,我们以最大值为例 最小同理
 *
 *          (1). 当数组中第一个数大于第二个数,我们可以说,第一个数为峰值直接返回即可
 *          (2). 当数组中最后一个数大于倒数第二个数,我们也可以说最后一个数为峰值直接返回即可
 *          (3). 以上情况都不符合,那么数组整体的形式是从左往右是递增形式,从右往左也是递增形式,所以在这两个数中间必有一个数是峰值
 *
 *              [1]. 此时我们使用二分法,找到中间的数,如果中间的数均大于两侧的数那么此时中间的数就是峰值
 *              [2]. 如果中间的数均小于两侧的数那么在左边或者右边都有峰值的存在,此时任意选一边
 *              [3]. 如果中间的数大于右边小于左边则继续往左边寻找,如果中间的数小于右边大于左边则往右边寻找
 */
public class _163_FindPeakElement {

    public int findPeakElement(int[] nums) {
        // 当数组只有一个值时,有前置条件说数组元素大于0个
        if (nums.length == 1) {
            return 0;
        }
        // 第一种情况,数组中第一个数大于第二个数
        if (nums[0] > nums[1]) {
            return 0;
        }
        // 第二种情况,数组中最后一个数大于倒数第二个数
        int len = nums.length;
        if (nums[len - 1] > nums[len - 2]) {
            return len - 1;
        }

        // 其他情况
        int result = 0;
        int left = 0;
        int right = len - 1;
        int mid = 0;
        while (left < right) {
            mid = (left + right) / 2;

            // 当中间的数大于两侧的数时,中间的数可以作为峰值返回
            if (nums[mid] > nums[mid + 1] && nums[mid] > nums[mid - 1]) {
                result = mid;
                break;
            }
            // 当中间的数小于右边的数,我们就继续往左边找
            if (nums[mid] < nums[mid + 1]) {
                // 注意这里不能写成 left = mid +1 因为这里的mid 加一会导致left >= right 直接导致跳出循环
                left = mid ;
            } else {
                // 我们这里是将第三种情况中的第二个点放在了右边
                // 继续往右边找
                // 这里也不能写成 right = mid -1 与上同理
                right = mid;
            }
        }
        // 返回下标
        return result;
    }
}
